forth_src:
	.ascii ": TRUE 1 ;\n"
	.ascii ": FALSE 0 ;\n"
	.ascii ": 0= 0 = ;\n"
	.ascii ": not 0= ;\n"
	.ascii ": <> = not ;\n"
	.ascii ": <= > not ;\n"
	.ascii ": >= < not ; \n"
	.ascii ": 0> 0 > ;\n"
	.ascii ": 0< 0 < ;\n"
	.ascii ": 0<= 0 <= ;\n"
	.ascii ": 0>= 0 >= ;\n"
	.ascii ": 0<> 0= not ;\n"
	.ascii ": 1+ 1 + ;\n"
	.ascii ": 1- 1 - ;\n"
	.ascii ": 4+ 4 + ;\n"
	.ascii ": 4- 4 - ; \n"
	.ascii ": negate 0 swap - ;\n"
	.ascii ": / /mod swap drop ; \n"
	.ascii ": mod /mod drop ;\n"
	.ascii ": BL 32 ;\n"
	.ascii ": '\\n' 10 ; \n"
	.ascii ": '\\t' 9 ;\n"
	.ascii ": space BL emit ;\n"
	.ascii ": CR '\\n' emit ;\n"
	.ascii ": tab '\\t' emit ;\n"
	.ascii ": literal immediate ' lit , , ; \n"
	.ascii ": '(' [ char ( ] literal ;\n"
	.ascii ": ')' [ char ) ] literal ;\n"
	.ascii ": ':' [ char : ] literal ;\n"
	.ascii ": ';' [ char ; ] literal ;\n"
	.ascii ": '.' [ char . ] literal ;\n"
	.ascii ": '"' [ char " ] literal ;\n"
	.ascii ": '-' [ char - ] literal ;\n"
	.ascii ": '0' [ char 0 ] literal ;\n"
	.ascii ": 'A' [ char A ] literal ;\n"
	.ascii ": [compile] word find >CFA , ;\n"
	.ascii "immediate\n"
	.ascii ": recurse Latest @ >CFA , ;\n"
	.ascii "immediate\n"
	.ascii ": if immediate\n"
	.ascii "\t' 0branch , Here @ 0 , ; \n"
	.ascii ": unless immediate\n"
	.ascii "\t' not , [compile] if ;\n"
	.ascii ": then immediate\n"
	.ascii "\tdup Here @ swap - swap ! ;  \n"
	.ascii ": else immediate\n"
	.ascii "\t' branch ,\n"
	.ascii "\tHere @\n"
	.ascii "\t0 ,\n"
	.ascii "\tswap dup\n"
	.ascii "\tHere @ swap -\n"
	.ascii "\tswap ! ;\n"
	.ascii ": begin immediate\n"
	.ascii "\tHere @ ; \n"
	.ascii ": UNTIL immediate\n"
	.ascii "\t' 0branch , Here @ - , ;\n"
	.ascii ": again immediate\n"
	.ascii "\t' branch ,\n"
	.ascii "\tHere @ - , ;\n"
	.ascii ": while immediate\n"
	.ascii "\t' 0branch ,\n"
	.ascii "\tHere @\n"
	.ascii "\t0 , ;\n"
	.ascii ": repeat immediate\n"
	.ascii "\t' branch ,\n"
	.ascii "\tswap\n"
	.ascii "\tHere @ - ,\n"
	.ascii "\tdup\n"
	.ascii "\tHere @ swap -\n"
	.ascii "\tswap ! ;\n"
	.ascii ": ( immediate\n"
	.ascii "\t1 \\ Push depth, starting as 1\n"
	.ascii "\tbegin\n"
	.ascii "\t\tKEY dup \\ Get a character\n"
	.ascii "\t\t'(' = if \\ Open paren --> increase depth\n"
	.ascii "\t\t\tdrop 1+\n"
	.ascii "\t\telse\n"
	.ascii "\t\t\t')' = if \\ Close paren --> decrease depth\n"
	.ascii "\t\t\t\t1-\n"
	.ascii "\t\t\tthen\n"
	.ascii "\t\tthen\n"
	.ascii "\tdup 0= UNTIL \\ Repeat until depth is 0\n"
	.ascii "\tdrop ; \\ drop depth counter\n"
	.ascii ": 2drop ( x x -- ) drop drop ; \n"
	.ascii ": 2dup ( x1 x2 -- x1 x2 x1 x2 ) over over ; \n"
	.ascii ": nip ( x y -- y ) swap drop ; \n"
	.ascii ": TUCK ( x y -- y x y ) swap over ; \n"
	.ascii ": pick ( x_u ... x_1 x_0 u -- x_u ... x_1 x_0 x_u )\n"
	.ascii "\t1+ 4 *\n"
	.ascii "\tDSP@ + @ ; \n"
	.ascii ": space ( n -- )\n"
	.ascii "\tbegin\n"
	.ascii "\t\tdup 0> \\ While n > 0\n"
	.ascii "\twhile\n"
	.ascii "\t\tSPACE 1- \\ Print a space, and decrement\n"
	.ascii "\trepeat\n"
	.ascii "\tdrop ;\n"
	.ascii ": hex ( -- )\n"
	.ascii "\t16 Base ! ;\n"
	.ascii ": decimal ( -- )\n"
	.ascii "\t10 Base ! ;\n"
	.ascii ": binary ( -- )\n"
	.ascii "\t2 Base ! ;\n"
	.ascii ": U. ( u -- )\n"
	.ascii "\tBase @ /MOD\n"
	.ascii "\t?dup if\n"
	.ascii "\t\trecurse\n"
	.ascii "\tthen\n"
	.ascii "\tdup 10 < if\n"
	.ascii "\t\t'0'\n"
	.ascii "\telse\n"
	.ascii "\t\t10 - 'A'\n"
	.ascii "\tthen\n"
	.ascii "\t+ emit ;\n"
	.ascii ": .s ( -- )\n"
	.ascii "\tDSP@\n"
	.ascii "\tbegin\n"
	.ascii "\t\tdup S0 @ <\n"
	.ascii "\twhile\n"
	.ascii "\t\tdup @ U.\n"
	.ascii "\t\tSPACE\n"
	.ascii "\t\t4+\n"
	.ascii "\trepeat\n"
	.ascii "\tdrop ;\n"
	.ascii ": uwidth\n"
	.ascii "\tBase @ /\n"
	.ascii "\t?dup if\n"
	.ascii "\t\trecurse 1+\n"
	.ascii "\telse\n"
	.ascii "\t\t1\n"
	.ascii "\tthen ;\n"
	.ascii ": U.R ( u width -- )\n"
	.ascii "\tswap dup\n"
	.ascii "\tuwidth\n"
	.ascii "\trot swap -\n"
	.ascii "\tspace \\ space will only print if n is positive\n"
	.ascii "\tU. ;\n"
	.ascii ": .R ( n width -- )\n"
	.ascii "\tswap ( width n )\n"
	.ascii "\tdup 0< if\n"
	.ascii "\t\tNEGATE ( width u )\n"
	.ascii "\t\t\\ Save a flag to remember the number was negative\n"
	.ascii "\t\t1 swap rot ( 1 u width )\n"
	.ascii "\t\t- ( 1 u width-1 )\n"
	.ascii "\telse\n"
	.ascii "\t\t0 swap rot ( 0 u width )\n"
	.ascii "\tthen\n"
	.ascii "\tswap dup ( flag width u u )\n"
	.ascii "\tuwidth ( flag width u uwidth )\n"
	.ascii "\trot swap - ( flag u width-uwidth )\n"
	.ascii "\tspace ( flag u )\n"
	.ascii "\tswap ( u flag )\n"
	.ascii "\tif '-' emit then \\ if it was negative, print the '-' sign\n"
	.ascii "\tU. ;\n"
	.ascii ": .\n"
	.ascii "\t0 .R\n"
	.ascii "\tSPACE ;\n"
	.ascii ": U.\n"
	.ascii "\tU. SPACE ;\n"
	.ascii ": ? ( addr -- )\n"
	.ascii "\t@ . ;\n"
	.ascii ": within ( c a b -- f) \\ where f is a<=c<b\n"
	.ascii "\t-rot\n"
	.ascii "\tover\n"
	.ascii "\t<= if\n"
	.ascii "\t\t> if TRUE\n"
	.ascii "\t\telse FALSE\n"
	.ascii "\t\tthen\n"
	.ascii "\telse\n"
	.ascii "\t\t2drop\n"
	.ascii "\t\tFALSE\n"
	.ascii "\tthen ;\n"
	.ascii ": DEPTH ( -- n )\n"
	.ascii "\tS0 @ DSP@ -\n"
	.ascii "\t4- ;\n"
	.ascii ": ALIGNED ( addr -- addr )\n"
	.ascii "\t3 +\n"
	.ascii "\t3 ~ & ;\n"
	.ascii ": ALIGN\n"
	.ascii "\tHere @ ALIGNED Here ! ;\n"
	.ascii ": +! ( x addr -- )\n"
	.ascii "\tdup ( x addr addr )\n"
	.ascii "\t@ ( x addr v )\n"
	.ascii "\trot + ( addr x+v )\n"
	.ascii "\tswap ( x+v addr )\n"
	.ascii "\t! ;\n"
	.ascii ": C,\n"
	.ascii "\tHere @ C!\n"
	.ascii "\t1 Here +! ;\n"
	.ascii ": S" immediate ( -- addr len )\n"
	.ascii "\tSTATE @ if \\ Compile mode\n"
	.ascii "\t\t' litSTRING ,\n"
	.ascii "\t\tHere @\n"
	.ascii "\t\t0 ,\n"
	.ascii "\t\tbegin\n"
	.ascii "\t\t\tKEY\n"
	.ascii "\t\t\tdup '"' <>\n"
	.ascii "\t\twhile\n"
	.ascii "\t\t\tC,\n"
	.ascii "\t\trepeat\n"
	.ascii "\t\tdrop\n"
	.ascii "\t\tdup\n"
	.ascii "\t\tHere @ swap -\n"
	.ascii "\t\t4-\n"
	.ascii "\t\tswap !\n"
	.ascii "\t\tALIGN\n"
	.ascii "\telse \\ Immediate mode\n"
	.ascii "\t\tHere @\n"
	.ascii "\t\tbegin\n"
	.ascii "\t\t\tKEY\n"
	.ascii "\t\t\tdup '"' <>\n"
	.ascii "\t\twhile\n"
	.ascii "\t\t\tover C!\n"
	.ascii "\t\t\t1+\n"
	.ascii "\t\trepeat\n"
	.ascii "\t\tdrop\n"
	.ascii "\t\tHere @ -\n"
	.ascii "\t\tHere @\n"
	.ascii "\t\tswap\n"
	.ascii "\tthen ;\n"
	.ascii ": ." immediate ( -- )\n"
	.ascii "\tSTATE @ if \\ Compile mode\n"
	.ascii "\t\t[compile] S"\n"
	.ascii "\t\t' TELL ,\n"
	.ascii "\telse \\ Immediate mode\n"
	.ascii "\t\tbegin\n"
	.ascii "\t\t\tKEY\n"
	.ascii "\t\t\tdup '"' = if\n"
	.ascii "\t\t\t\tdrop exit\n"
	.ascii "\t\t\tthen\n"
	.ascii "\t\t\temit\n"
	.ascii "\t\tagain\n"
	.ascii "\tthen ;\n"
	.ascii ": SKIPLINK 4+ ;\n"
	.ascii ": ID. ( addr -- )\n"
	.ascii "\tSKIPLINK\n"
	.ascii "\tdup C@ \\ get flags and length byte\n"
	.ascii "\tF_LENMASK & \\ get just the length\n"
	.ascii "\tbegin\n"
	.ascii "\t\tdup 0>\n"
	.ascii "\twhile \\ while length > 0\n"
	.ascii "\t\tswap 1+\n"
	.ascii "\t\tdup C@\n"
	.ascii "\t\temit\n"
	.ascii "\t\tswap 1-\n"
	.ascii "\trepeat\n"
	.ascii "\t2drop ;\n"
	.ascii ": ?hidden ( addr -- flag )\n"
	.ascii "\tSKIPLINK\n"
	.ascii "\tC@ F_hidden & ;\n"
	.ascii ": ?immediate ( addr -- flag )\n"
	.ascii "\tSKIPLINK\n"
	.ascii "\tC@\n"
	.ascii "\tF_IMMED & ;\n"
	.ascii ": wordS ( -- )\n"
	.ascii "\tLatest @\n"
	.ascii "\tbegin\n"
	.ascii "\t\t?dup\n"
	.ascii "\twhile\n"
	.ascii "\t\tdup ?hidden not if\n"
	.ascii "\t\t\tdup ID.\n"
	.ascii "\t\t\tSPACE\n"
	.ascii "\t\tthen\n"
	.ascii "\t\t@\n"
	.ascii "\trepeat\n"
	.ascii "\tCR ;\n"
	.ascii ": forget ( -- )\n"
	.ascii "\tword find\n"
	.ascii "\tdup @\n"
	.ascii "\tLatest !\n"
	.ascii "\tHere ! ;\n"
	.ascii ": dump ( addr len -- )\n"
	.ascii "\tBase @ -rot\n"
	.ascii "\thex\n"
	.ascii "\tbegin\n"
	.ascii "\t\t?dup\n"
	.ascii "\twhile\n"
	.ascii "\t\tover 8 U.R\n"
	.ascii "\t\tSPACE\n"
	.ascii "\t\t\\ Print up to 16 words per line\n"
	.ascii "\t\t2dup\n"
	.ascii "\t\t1- 15 & 1+\n"
	.ascii "\t\tbegin\n"
	.ascii "\t\t\t?dup\n"
	.ascii "\t\twhile\n"
	.ascii "\t\t\tswap\n"
	.ascii "\t\t\tdup C@\n"
	.ascii "\t\t\t2 .R SPACE\n"
	.ascii "\t\t\t1+ swap 1-\n"
	.ascii "\t\trepeat\n"
	.ascii "\t\tdrop\n"
	.ascii "\t\t2dup 1- 15 & 1+\n"
	.ascii "\t\tbegin\n"
	.ascii "\t\t\t?dup\n"
	.ascii "\t\twhile\n"
	.ascii "\t\t\tswap\n"
	.ascii "\t\t\tdup C@\n"
	.ascii "\t\t\tdup 32 128 within if\n"
	.ascii "\t\t\t\temit\n"
	.ascii "\t\t\telse\n"
	.ascii "\t\t\t\tdrop '.' emit\n"
	.ascii "\t\t\tthen\n"
	.ascii "\t\t\t1+ swap 1-\n"
	.ascii "\t\trepeat\n"
	.ascii "\t\tdrop\n"
	.ascii "\t\tCR\n"
	.ascii "\t\tdup 1- 15 & 1+\n"
	.ascii "\t\tTUCK\n"
	.ascii "\t\t-\n"
	.ascii "\t\t>R + R>\n"
	.ascii "\trepeat\n"
	.ascii "\tdrop\n"
	.ascii "\tBase ! ; \\ Restore the saved base\n"
	.ascii ": case immediate\n"
	.ascii "\t0 ;\n"
	.ascii ": of immediate\n"
	.ascii "\t' over ,\n"
	.ascii "\t' = ,\n"
	.ascii "\t[compile] if\n"
	.ascii "\t' drop , ;\n"
	.ascii ": endof immediate\n"
	.ascii "\t[compile] else ;\n"
	.ascii ": endcase immediate\n"
	.ascii "\t' drop ,\n"
	.ascii "\tbegin\n"
	.ascii "\t\t?dup\n"
	.ascii "\twhile\n"
	.ascii "\t\t[compile] then\n"
	.ascii "\trepeat ;\n"
	.ascii ": CFA>\n"
	.ascii "\tLatest @\n"
	.ascii "\tbegin\n"
	.ascii "\t\t?dup\n"
	.ascii "\twhile\n"
	.ascii "\t\t2dup swap\n"
	.ascii "\t\t< if\n"
	.ascii "\t\t\t\\ Found, so leave current dictionary entry on the stack\n"
	.ascii "\t\t\tnip\n"
	.ascii "\t\t\texit\n"
	.ascii "\t\tthen\n"
	.ascii "\t\t@\n"
	.ascii "\trepeat\n"
	.ascii "\t\\ Nothing found\n"
	.ascii "\tdrop\n"
	.ascii "\t0 ;\n"
	.ascii ": see\n"
	.ascii "\tword find\n"
	.ascii "\tdup if\n"
	.ascii "\t\t\\ Decompile if the word was found\n"
	.ascii "\t\tHere @\n"
	.ascii "\t\tLatest @\n"
	.ascii "\t\tbegin\n"
	.ascii "\t\t\t2 pick\n"
	.ascii "\t\t\tover\n"
	.ascii "\t\t\t<>\n"
	.ascii "\t\twhile\n"
	.ascii "\t\t\tnip\n"
	.ascii "\t\t\tdup @\n"
	.ascii "\t\trepeat\n"
	.ascii "\t\tdrop swap\n"
	.ascii "\t\t\\ Start printing out the source\n"
	.ascii "\t\t':' emit SPACE dup ID. SPACE\n"
	.ascii "\t\tdup ?immediate if ." immediate " then\n"
	.ascii "\t\t>DFA\n"
	.ascii "\t\tbegin\n"
	.ascii "\t\t\t2dup >\n"
	.ascii "\t\twhile\n"
	.ascii "\t\t\tdup @\n"
	.ascii "\t\t\tcase\n"
	.ascii "\t\t\t\t' lit of\n"
	.ascii "\t\t\t\t\t4 + dup @\n"
	.ascii "\t\t\t\t\t.\n"
	.ascii "\t\t\t\t\tendof\n"
	.ascii "\t\t\t\t' litSTRING of\n"
	.ascii "\t\t\t\t\t[ char S ] literal emit '"' emit SPACE\n"
	.ascii "\t\t\t\t\t4 + dup @\n"
	.ascii "\t\t\t\t\tswap 4 + swap\n"
	.ascii "\t\t\t\t\t2dup TELL\n"
	.ascii "\t\t\t\t\t'"' emit SPACE\n"
	.ascii "\t\t\t\t\t+ ALIGNED\n"
	.ascii "\t\t\t\t\t4 -\n"
	.ascii "\t\t\t\t\tendof\n"
	.ascii "\t\t\t\t' 0branch of\n"
	.ascii "\t\t\t\t\t." 0branch ( "\n"
	.ascii "\t\t\t\t\t4 + dup @ .\n"
	.ascii "\t\t\t\t\t." ) "\n"
	.ascii "\t\t\t\t\tendof\n"
	.ascii "\t\t\t\t' branch of\n"
	.ascii "\t\t\t\t\t." branch ( "\n"
	.ascii "\t\t\t\t\t4 + dup @ .\n"
	.ascii "\t\t\t\t\t." ) "\n"
	.ascii "\t\t\t\t\tendof\n"
	.ascii "\t\t\t\t' ' of\n"
	.ascii "\t\t\t\t\t[ char ' ] literal emit SPACE\n"
	.ascii "\t\t\t\t\t4 + dup @\n"
	.ascii "\t\t\t\t\tCFA>\n"
	.ascii "\t\t\t\t\tID. SPACE\n"
	.ascii "\t\t\t\t\tendof\n"
	.ascii "\t\t\t\t' exit of\n"
	.ascii "\t\t\t\t\t2dup\n"
	.ascii "\t\t\t\t\t4 +\n"
	.ascii "\t\t\t\t\t<> if\n"
	.ascii "\t\t\t\t\t\t." exit "\n"
	.ascii "\t\t\t\t\tthen\n"
	.ascii "\t\t\t\t\tendof\n"
	.ascii "\t\t\t\tdup\n"
	.ascii "\t\t\t\tCFA>\n"
	.ascii "\t\t\t\tID. SPACE\n"
	.ascii "\t\t\tendcase\n"
	.ascii "\t\t\t4 +\n"
	.ascii "\t\trepeat\n"
	.ascii "\t\t';' emit CR\n"
	.ascii "\t\t2drop \n"
	.ascii "\telse\n"
	.ascii "\t\t\\ The word was not found\n"
	.ascii "\t\t." undefined. "\n"
	.ascii "\tthen ;\n"
	.ascii ": :NONAME\n"
	.ascii "\t0 0 CREATE\n"
	.ascii "\tHere @\n"
	.ascii "\tDOCOL ,\n"
	.ascii "\t] ;\n"
	.ascii ": ['] immediate\n"
	.ascii "\t' lit , ;\n"
	.ascii ": exception-marker\n"
	.ascii "\tRdrop\n"
	.ascii "\t0 ;\n"
	.ascii ": catch ( xt -- exn? )\n"
	.ascii "\tDSP@ 4+ >R\n"
	.ascii "\t' exception-marker 4+\n"
	.ascii "\t>R\n"
	.ascii "\tEXECUTE ;\n"
	.ascii ": throw ( n -- )\n"
	.ascii "\t?dup if\n"
	.ascii "\t\tRSP@\n"
	.ascii "\t\tbegin\n"
	.ascii "\t\t\tdup R0 4- <\n"
	.ascii "\t\twhile\n"
	.ascii "\t\t\tdup @\n"
	.ascii "\t\t\t' exception-marker 4+ = if\n"
	.ascii "\t\t\t\t4+\n"
	.ascii "\t\t\t\tRSP!\n"
	.ascii "\t\t\t\tdup dup dup\n"
	.ascii "\t\t\t\tR>\n"
	.ascii "\t\t\t\t4-\n"
	.ascii "\t\t\t\tswap over\n"
	.ascii "\t\t\t\t!\n"
	.ascii "\t\t\t\tDSP! exit\n"
	.ascii "\t\t\tthen\n"
	.ascii "\t\t\t4+\n"
	.ascii "\t\trepeat\n"
	.ascii "\t\t\\ No catch for this exception, so print a message and restart the\n"
	.ascii "\t\t\\ Interpreter.\n"
	.ascii "\t\tdrop\n"
	.ascii "\t\tcase \n"
	.ascii "\t\t\t0 1- of\n"
	.ascii "\t\t\t\t." ABORTED" CR\n"
	.ascii "\t\t\t\tendof\n"
	.ascii "\t\t\t." UNCAUGHT throw "\n"
	.ascii "\t\t\tdup . CR\n"
	.ascii "\t\tendcase\n"
	.ascii "\t\tQUIT\n"
	.ascii "\tthen ;\n"
	.ascii ": abort ( -- )\n"
	.ascii "\t0 1- throw ;\n"
	.ascii ": print-stack-trace\n"
	.ascii "\tRSP@\n"
	.ascii "\tbegin\n"
	.ascii "\t\tdup R0 4- <\n"
	.ascii "\twhile\n"
	.ascii "\t\tdup @\n"
	.ascii "\t\tcase\n"
	.ascii "\t\t\t' exception-marker 4+ of\n"
	.ascii "\t\t\t\t." catch ( DSP="\n"
	.ascii "\t\t\t\t4+ dup @ U.\n"
	.ascii "\t\t\t\t." ) "\n"
	.ascii "\t\t\t\tendof\n"
	.ascii "\t\t\tdup\n"
	.ascii "\t\t\tCFA>\n"
	.ascii "\t\t\t?dup if\n"
	.ascii "\t\t\t\t2dup\n"
	.ascii "\t\t\t\tID.\n"
	.ascii "\t\t\t\t[ char + ] literal emit\n"
	.ascii "\t\t\t\tswap >DFA 4+ - .\n"
	.ascii "\t\t\tthen\n"
	.ascii "\t\tendcase\n"
	.ascii "\t\t4+\n"
	.ascii "\trepeat\n"
	.ascii "\tdrop\n"
	.ascii "\tCR ;\n"
	.ascii ": CELLS ( n -- n ) 4 * ;\n"
	.ascii ": syscall0 0 SYSCALL ;\n"
	.ascii ": syscall1 1 SYSCALL ;\n"
	.ascii ": syscall2 2 SYSCALL ;\n"
	.ascii ": syscall3 3 SYSCALL ;\n"
	.ascii ": syscall ;\n"
	.ascii ": halt\n"
	.ascii "\t0 SYS_exit syscall1 ;\n"
	.ascii ": get-brk ( -- brkpoint )\n"
	.ascii "\t0 SYS_brk syscall1 ;\n"
	.ascii ": unused ( -- n )\n"
	.ascii "\tget-brk\n"
	.ascii "\tHere @\n"
	.ascii "\t-\n"
	.ascii "\t4 / ;\n"
	.ascii ": brk ( brkpoint -- )\n"
	.ascii "\tSYS_BRK syscall1 ;\n"
	.ascii ": morecore ( cells -- )\n"
	.ascii "\tCELLS get-brk + brk ;\n"
	.ascii ": hide \n"
	.ascii "\tword find dup if\n"
	.ascii "\t\thidden\n"
	.ascii "\tthen ; \n"
	.ascii ": bye\n"
	.ascii "\t."  bye. "\n"
	.ascii "\thalt ;\n"
	.ascii ": ok ."  ok." ;\n"
	.ascii ": hello\n"
	.ascii "\t." FemtoForth version " VERSION . CR\n"
	.ascii "\tunused . ." memory cells remaining" CR\n"
	.ascii "\tok CR ; \n"
	.ascii "hello\n"
	.ascii "hide hello\n"
